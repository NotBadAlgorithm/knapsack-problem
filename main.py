#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from decimal import Decimal
from collections import defaultdict
import sys
sys.stdin = open('input.txt')


class KnapsackItem:
    """Один предмет в рюкзаке"""

    def __init__(self, name, size, price):
        # Наименование предмета
        self.name = name
        # Для размера и ценности предмета специально используется
        # тип Decimal, чтобы более точно работать с вещественными числами,
        # в частности нахождения остатка от деления на вещ. число
        # Размер предмета
        self.size = Decimal(size)
        # Ценность предмета
        self.price = Decimal(price)


def input_data():
    """Получаем данные от пользователя"""
    # Общая ёмкость всего рюкзака
    capacity = Decimal(input())

    # Массив с инфомацией о предметах (инвентарь)
    inventory = []

    # Обходим все предметы, что есть
    for line in sys.stdin:
        # Собираем параметры для каждого предмета (название, размер, ценность)
        name, size, price = line.split()
        # Добавляем новый предмет к остальным
        inventory.append(KnapsackItem(name, size, price))

    # результат обработки данных от пользователя - это
    # возможная вмещаемость рюкзака и все возможные прдеметы
    return capacity, inventory


def get_knapsack_volumes(capacity, inventory):
    """
    Получить разбиение рюкзака на части (подрюкзаки - подобъёмы)
    capacity - ёмкость всего рюкзака
    inventory - список всех возможных предметов
    """
    # По сути это задача нахождения Наибольшего Общего Делителя (НОД)
    # для всех размеров предметов и ёмкости самого рюкзака

    # Множество размеров всех предметов
    # У нескольких предметов может быть один и тот же размер
    # Чтобы ускорить вычисления испольуем множество, а не список
    sizes = set(ks_item.size for ks_item in inventory)
    # Также к множеству всех размеров нужно добавить размер всего рюкзака
    # Так как дальше будет строится таблица
    # от минимальноного подрюкака до общего
    sizes.add(capacity)

    # Размер минимального предмета в рюкзаке - это первоначальное приближение
    # значения шага подрюкзаков
    step = min(sizes)

    # Пока не найдём нужный оптимальный шаг
    while True:
        # Обходим размеры всех предметов в наборе
        for size in sizes:
            # Находим значение остатка от деления размера предмета на шаг
            remainder = size % step
            # если остаток от деления НЕ нулевой
            if remainder != Decimal('0'):
                # Назначаем новый шаг
                step = remainder
                # И выходим из внутреннего цикла for
                # Возвращаемся к while
                break
        else:
            # Если цикл for отработал без обрывания break
            # Значит мы нашли нужный шаг
            # Выходим из внешнего цикла while
            break

    # Здесь мы точно УЖЕ получили значение шага подрюкзаков - step
    # создадим массив подрюкзаков
    # int(...) преоббразует Decimal к типу int
    # это нужно для функции range, которая принимает только целые числа
    ks_volumes = [i*step for i in range(1, int(capacity / step)+1)]

    # И возвращаем все подобъёмы нашего рюкзака
    return ks_volumes


def find_optimal_set(capacity, inventory):
    """Найти оптимальный набор предметов"""
    # Размеры подрюкзаков - массив чисел Decimal
    ks_volumes = get_knapsack_volumes(capacity, inventory)

    # Заготовка для таблицы с вычислениями
    # К ечейки таблицы будем обращаться так tab[i, volume]
    # cначала указываем i - индекс предмета в инвентаре
    # потом через запятую размер подрюказка
    # python позволяет такую запись, так как как кортеж
    # из чисел имеет не изменяющийся хеш
    # Дальше нам нужно хранить в ячейке таблицы
    # одновременно и ЦЕННОСТЬ предметов и НАБОР этих предметов
    # Для простоты будем просто хранить индексы предметов в инвентаре
    # Сначала заполним всё нулями - текущая оценка стоимости подрюкзака
    # и пустыми массивами - так как еще нет никаких наборов предметов
    tab = defaultdict(lambda: {'price': Decimal('0'), 'items': []})

    # Заполняем построчно таблицу для расчётов
    # Обходим все строки таблицы
    for i, item in enumerate(inventory):
        # Обходим столбцы текущей строки
        for volume in ks_volumes:
            # Находим предыдущий максимум
            before_max = tab[i-1, volume]['price']
            # Находим возможный новый максимум
            # Если предмет помещается в текущий подрюкзак
            if item.size <= volume:
                # Это цена текущего предмета + ценность оставшегося пространства
                new_max = item.price + tab[i-1, volume-item.size]['price']
            else:
                # Если не помещается, то это любое отрицательное число
                # так как в этом случае ценность данного подрюкзака
                # это предыдущий максимум
                # Минимально возможный предыдущий максимум = 0, тогда
                # для расчётов нам нужно просто для текущего
                # максимума указать число < 0, пусть это будет -1
                new_max = -1

            # Заметьте, что если ячейки не существует в таблице, то благодаря
            # defaultdict к ней можно обратиться и получить, что её ценность = 0,
            # что упрощает код и не влияет на вычисления

            # Выбираем из двух максимумов больший и заполяем тукущую ячейку
            if before_max > new_max:
                # Ценность подрюкзака - ценость пердыдущего максимума
                tab[i, volume]['price'] = before_max
                # Набор предметов также берем из предыдущего максимального
                tab[i, volume]['items'] = tab[i-1, volume]['items']
            else:
                # Ценность подрюкзака - ценость нового максимума
                tab[i, volume]['price'] = new_max

                # набор предметов - текущий предмет
                tab[i, volume]['items'].append(i)
                # + предметы из оставшегося пустого пространства
                empty_items = tab[i-1, volume-item.size]['items']
                tab[i, volume]['items'].extend(empty_items)

    # В самом последней ячейки таблицы будет оптимальный набор предметов
    # с суммарной максимальной стоимостью
    # Индексы оптимальных предметов
    index_ks_set = tab[len(inventory)-1, ks_volumes[-1]]['items']

    return index_ks_set


def output_results(capacity, inventory, index_ks_set):
    """Вывод результатов"""
    # Итоговая ценность
    score = Decimal('0')
    # Итоговый суммарный объём
    volume = Decimal('0')
    print(f'Набор предметов в рюкзаке ёмкостью "{capacity}":')
    # Заголовок таблицы
    print(f'\t{"Предмет":^10}| размер | ценность |')
    print('-'*40)
    # Строки с предметами
    for i in index_ks_set:
        # Получаем предмет из инвенторя
        item = inventory[i]
        print(f'\t{item.name:<10}|{item.size:>8}|{item.price:>10}|')
        volume += item.size
        score += item.price
    # Итоговая самая нижняя строка
    print('-'*40)
    print(f'\t{"СУММА":<10}|{volume:>8}|{score:>10}|')


def main():
    """Основная программа"""
    # Получаем данные от пользователя
    # Вмещаемость рюкзака и все возможные предметы
    capacity, inventory = input_data()
    # Решаем задачу, получая набор предметов,
    # что в сумме дадут максимальную ценность
    index_ks_set = find_optimal_set(capacity, inventory)
    # Выводим результаты
    output_results(capacity, inventory, index_ks_set)


# Стартовая точка запуска программы
if __name__ == "__main__":
    main()
